#!/usr/bin/env ruby

require 'msf/core'

class MetasploitModule < Msf::Auxiliary
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Custom Port Scanner',
      'Description'    => %q{
        Scan a range of TCP ports on a target and report which ports are open.
      },
      'Author'         => ['Your Name'],
      'License'        => MSF_LICENSE
    ))

    register_options(
      [
        OptInt.new('STARTPORT', [true, 'Starting TCP port', 1]),
        OptInt.new('ENDPORT',   [true, 'Ending TCP port', 1024]),
        OptInt.new('TIMEOUT',   [false, 'Connection timeout in seconds', 1])
      ], self.class
    )
  end

  def run_host(target_host)
    start_port = datastore['STARTPORT'].to_i
    end_port   = datastore['ENDPORT'].to_i
    timeout    = datastore['TIMEOUT'] ? datastore['TIMEOUT'].to_f : 1.0

    unless valid_params?(start_port, end_port)
      print_error('Invalid port range. STARTPORT must be <= ENDPORT, and both in 1..65535')
      return
    end

    open_ports = []

    (start_port..end_port).each do |port|
      sock = nil
      begin
        sock = Rex::Socket::Tcp.create(
          'PeerHost' => target_host,
          'PeerPort' => port,
          'Timeout'  => timeout
        )

        if sock
          print_good("#{target_host}:#{port} - Port #{port} is open")
          open_ports << port
        end
      rescue Rex::ConnectionError, ::Errno::ECONNREFUSED, ::Errno::ETIMEDOUT, ::IOError
        # closed or unreachable
      ensure
        if sock
          begin
            sock.close
          rescue ::IOError
          end
        end
      end
    end

    if open_ports.any?
      print_status("Open ports on #{target_host}: #{open_ports.join(', ')}")
    else
      print_status("No open ports found on #{target_host} in range #{start_port}-#{end_port}")
    end
  end

  def valid_params?(start_port, end_port)
    return false if start_port.nil? || end_port.nil?
    return false unless start_port.is_a?(Integer) && end_port.is_a?(Integer)
    return false unless start_port >= 1 && end_port <= 65_535
    return false unless start_port <= end_port
    true
  end
end
